(defpackage "DAY2/K"
  (:use "CL"
        "CL-KANREN")
  (:shadow "STEP"))
(in-package "DAY2/K")

(defun up (start end)
  (conde
    ((== start 1)
     (== end 1))
    ((== start 2)
     (== end 2))
    ((== start 3)
     (== end 3))
    ((== start 4)
     (== end 1))
    ((== start 5)
     (== end 2))
    ((== start 6)
     (== end 3))
    ((== start 7)
     (== end 4))
    ((== start 8)
     (== end 5))
    ((== start 9)
     (== end 6))))

(defun down (start end)
  (conde
    ((== start 1)
     (== end 4))
    ((== start 2)
     (== end 5))
    ((== start 3)
     (== end 6))
    ((== start 4)
     (== end 7))
    ((== start 5)
     (== end 8))
    ((== start 6)
     (== end 9))
    ((== start 7)
     (== end 7))
    ((== start 8)
     (== end 8))
    ((== start 9)
     (== end 9))))

(defun right (start end)
  (conde
    ((== start 1)
     (== end 2))
    ((== start 2)
     (== end 3))
    ((== start 3)
     (== end 3))
    ((== start 4)
     (== end 5))
    ((== start 5)
     (== end 6))
    ((== start 6)
     (== end 6))
    ((== start 7)
     (== end 8))
    ((== start 8)
     (== end 9))
    ((== start 9)
     (== end 9))))

(defun left (start end)
  (conde
    ((== start 1)
     (== end 1))
    ((== start 2)
     (== end 1))
    ((== start 3)
     (== end 2))
    ((== start 4)
     (== end 4))
    ((== start 5)
     (== end 4))
    ((== start 6)
     (== end 5))
    ((== start 7)
     (== end 7))
    ((== start 8)
     (== end 7))
    ((== start 9)
     (== end 8))))

(defun next-step (fresh-var path start end)
  (fresh ()
    (conde
      ((== fresh-var 'up))
      ((== fresh-var 'down))
      ((== fresh-var 'right))
      ((== fresh-var 'left)))
    (caro path fresh-var)
    (funcall fresh-var start end)))

(defun path-from (pos path end-pos)
  (fresh (x y)
    (conda
      ((nullo path) (== pos end-pos))
      ((next-step y path)
       (funcall y pos x)
       (path-from x (cdr path) end-pos)))))

(run 1 (y)
  (next-step y '(left left up) 4 4))
(run 3 (x) (up x x))
(run 1 (x) (path-from 5 '(left left up) x)) ; => (1)
(values (run 3 (x) (next-step x '(left left up) 4)) (run 1 (x) (step 5 x 1)))
